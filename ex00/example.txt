// ScalarConverter.hpp
#ifndef SCALARCONVERTER_HPP
#define SCALARCONVERTER_HPP

#include <string>
#include <iostream>
#include <iomanip>
#include <limits>
#include <cstdlib>
#include <cctype>
#include <cmath>

class ScalarConverter {
private:
    enum Type {
        CHAR,
        INT,
        FLOAT,
        DOUBLE,
        INVALID
    };

    // Make class non-instantiable
    ScalarConverter();
    ScalarConverter(const ScalarConverter& other);
    ScalarConverter& operator=(const ScalarConverter& other);
    ~ScalarConverter();

    // Helper methods
    static Type detectType(const std::string& input);
    static bool isChar(const std::string& input);
    static bool isInt(const std::string& input);
    static bool isFloat(const std::string& input);
    static bool isDouble(const std::string& input);
    static bool isSpecialFloat(const std::string& input);
    static bool isSpecialDouble(const std::string& input);
    
    static void convertFromChar(char c);
    static void convertFromInt(int value);
    static void convertFromFloat(float value);
    static void convertFromDouble(double value);
    
    static void printChar(double value, bool impossible = false);
    static void printInt(double value, bool impossible = false);
    static void printFloat(double value);
    static void printDouble(double value);

public:
    static void convert(const std::string& input);
};

#endif

// ScalarConverter.cpp
#include "ScalarConverter.hpp"

ScalarConverter::ScalarConverter() {}
ScalarConverter::ScalarConverter(const ScalarConverter& other) { (void)other; }
ScalarConverter& ScalarConverter::operator=(const ScalarConverter& other) { (void)other; return *this; }
ScalarConverter::~ScalarConverter() {}

void ScalarConverter::convert(const std::string& input) {
    if (input.empty()) {
        std::cout << "Error: Empty input" << std::endl;
        return;
    }

    Type type = detectType(input);
    
    switch (type) {
        case CHAR: {
            char c = input[1]; // Extract char from 'c'
            convertFromChar(c);
            break;
        }
        case INT: {
            long long temp = std::atoll(input.c_str());
            if (temp > std::numeric_limits<int>::max() || temp < std::numeric_limits<int>::min()) {
                printChar(0, true);
                std::cout << "int: impossible" << std::endl;
                printFloat(static_cast<float>(temp));
                printDouble(static_cast<double>(temp));
            } else {
                int value = static_cast<int>(temp);
                convertFromInt(value);
            }
            break;
        }
        case FLOAT: {
            float value;
            if (isSpecialFloat(input)) {
                if (input == "nanf" || input == "+nanf" || input == "-nanf")
                    value = std::numeric_limits<float>::quiet_NaN();
                else if (input == "+inff" || input == "inff")
                    value = std::numeric_limits<float>::infinity();
                else if (input == "-inff")
                    value = -std::numeric_limits<float>::infinity();
            } else {
                value = static_cast<float>(std::atof(input.c_str()));
            }
            convertFromFloat(value);
            break;
        }
        case DOUBLE: {
            double value;
            if (isSpecialDouble(input)) {
                if (input == "nan" || input == "+nan" || input == "-nan")
                    value = std::numeric_limits<double>::quiet_NaN();
                else if (input == "+inf" || input == "inf")
                    value = std::numeric_limits<double>::infinity();
                else if (input == "-inf")
                    value = -std::numeric_limits<double>::infinity();
            } else {
                value = std::atof(input.c_str());
            }
            convertFromDouble(value);
            break;
        }
        default:
            std::cout << "Error: Invalid input format" << std::endl;
            return;
    }
}

ScalarConverter::Type ScalarConverter::detectType(const std::string& input) {
    if (isChar(input)) return CHAR;
    if (isFloat(input)) return FLOAT;
    if (isDouble(input)) return DOUBLE;
    if (isInt(input)) return INT;
    return INVALID;
}

bool ScalarConverter::isChar(const std::string& input) {
    return input.length() == 3 && input[0] == '\'' && input[2] == '\'' && std::isprint(input[1]);
}

bool ScalarConverter::isInt(const std::string& input) {
    if (input.empty()) return false;
    
    size_t start = 0;
    if (input[0] == '+' || input[0] == '-')
        start = 1;
    
    if (start >= input.length()) return false;
    
    for (size_t i = start; i < input.length(); i++) {
        if (!std::isdigit(input[i])) return false;
    }
    return true;
}

bool ScalarConverter::isFloat(const std::string& input) {
    if (isSpecialFloat(input)) return true;
    
    if (input.length() < 2 || input[input.length() - 1] != 'f') return false;
    
    std::string withoutF = input.substr(0, input.length() - 1);
    return isDouble(withoutF);
}

bool ScalarConverter::isDouble(const std::string& input) {
    if (isSpecialDouble(input)) return true;
    
    if (input.empty()) return false;
    
    size_t start = 0;
    if (input[0] == '+' || input[0] == '-')
        start = 1;
    
    bool hasDot = false;
    bool hasDigit = false;
    
    for (size_t i = start; i < input.length(); i++) {
        if (input[i] == '.') {
            if (hasDot) return false;
            hasDot = true;
        } else if (std::isdigit(input[i])) {
            hasDigit = true;
        } else {
            return false;
        }
    }
    
    return hasDigit && hasDot;
}

bool ScalarConverter::isSpecialFloat(const std::string& input) {
    return input == "nanf" || input == "+nanf" || input == "-nanf" ||
           input == "inff" || input == "+inff" || input == "-inff";
}

bool ScalarConverter::isSpecialDouble(const std::string& input) {
    return input == "nan" || input == "+nan" || input == "-nan" ||
           input == "inf" || input == "+inf" || input == "-inf";
}

void ScalarConverter::convertFromChar(char c) {
    std::cout << "char: '" << c << "'" << std::endl;
    std::cout << "int: " << static_cast<int>(c) << std::endl;
    std::cout << "float: " << std::fixed << std::setprecision(1) << static_cast<float>(c) << "f" << std::endl;
    std::cout << "double: " << std::fixed << std::setprecision(1) << static_cast<double>(c) << std::endl;
}

void ScalarConverter::convertFromInt(int value) {
    printChar(static_cast<double>(value));
    std::cout << "int: " << value << std::endl;
    std::cout << "float: " << std::fixed << std::setprecision(1) << static_cast<float>(value) << "f" << std::endl;
    std::cout << "double: " << std::fixed << std::setprecision(1) << static_cast<double>(value) << std::endl;
}

void ScalarConverter::convertFromFloat(float value) {
    bool isSpecial = std::isnan(value) || std::isinf(value);
    
    printChar(static_cast<double>(value), isSpecial);
    printInt(static_cast<double>(value), isSpecial);
    printFloat(static_cast<double>(value));
    printDouble(static_cast<double>(value));
}

void ScalarConverter::convertFromDouble(double value) {
    bool isSpecial = std::isnan(value) || std::isinf(value);
    
    printChar(value, isSpecial);
    printInt(value, isSpecial);
    printFloat(value);
    printDouble(value);
}

void ScalarConverter::printChar(double value, bool impossible) {
    if (impossible || std::isnan(value) || std::isinf(value)) {
        std::cout << "char: impossible" << std::endl;
    } else if (value < 0 || value > 127) {
        std::cout << "char: impossible" << std::endl;
    } else if (value < 32 || value == 127) {
        std::cout << "char: Non displayable" << std::endl;
    } else {
        std::cout << "char: '" << static_cast<char>(value) << "'" << std::endl;
    }
}

void ScalarConverter::printInt(double value, bool impossible) {
    if (impossible || std::isnan(value) || std::isinf(value) ||
        value > std::numeric_limits<int>::max() || value < std::numeric_limits<int>::min()) {
        std::cout << "int: impossible" << std::endl;
    } else {
        std::cout << "int: " << static_cast<int>(value) << std::endl;
    }
}

void ScalarConverter::printFloat(double value) {
    if (std::isnan(value)) {
        std::cout << "float: nanf" << std::endl;
    } else if (std::isinf(value)) {
        if (value > 0)
            std::cout << "float: +inff" << std::endl;
        else
            std::cout << "float: -inff" << std::endl;
    } else {
        float f = static_cast<float>(value);
        if (f == static_cast<int>(f) && f <= 1000000 && f >= -1000000) {
            std::cout << "float: " << std::fixed << std::setprecision(1) << f << "f" << std::endl;
        } else {
            std::cout << "float: " << f << "f" << std::endl;
        }
    }
}

void ScalarConverter::printDouble(double value) {
    if (std::isnan(value)) {
        std::cout << "double: nan" << std::endl;
    } else if (std::isinf(value)) {
        if (value > 0)
            std::cout << "double: +inf" << std::endl;
        else
            std::cout << "double: -inf" << std::endl;
    } else {
        if (value == static_cast<int>(value) && value <= 1000000 && value >= -1000000) {
            std::cout << "double: " << std::fixed << std::setprecision(1) << value << std::endl;
        } else {
            std::cout << "double: " << value << std::endl;
        }
    }
}

// main.cpp
#include "ScalarConverter.hpp"

int main(int argc, char** argv) {
    if (argc != 2) {
        std::cout << "Usage: " << argv[0] << " <value>" << std::endl;
        return 1;
    }
    
    ScalarConverter::convert(argv[1]);
    return 0;
}

// Makefile
/*
NAME = convert
CXX = c++
CXXFLAGS = -Wall -Wextra -Werror -std=c++98

SRCDIR = .
SOURCES = main.cpp ScalarConverter.cpp
OBJECTS = $(SOURCES:.cpp=.o)

all: $(NAME)

$(NAME): $(OBJECTS)
	$(CXX) $(CXXFLAGS) $(OBJECTS) -o $(NAME)

%.o: %.cpp
	$(CXX) $(CXXFLAGS) -c $< -o $@

clean:
	rm -f $(OBJECTS)

fclean: clean
	rm -f $(NAME)

re: fclean all

.PHONY: all clean fclean re
*/